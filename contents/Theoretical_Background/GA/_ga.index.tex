\section{Genetic Algorithms}
\label{sec:bg:ga}
  Genetic Algorithms (GA)\footnote{
    Also known as Simple Genetic Algorithms (SGA) \autocite{yuIntroductionEvolutionaryAlgorithms2010}, or Traditional 
    Genetic Algorithms (TGA)~\autocite{shiffmanNatureCode2012}.
  }~\autocite{hollandAdaptationNaturalArtificial1992a,kozaGeneticProgrammingProgramming1992a,yuIntroductionEvolutionaryAlgorithms2010,shiffmanNatureCode2012}
  are a type of EA where a \emph{population} of \emph{individuals}\footnote{
    \emph{Individual:} A candidate solution to a given optimization problem. Formally, an individual is a pair \((\mathbf{G}, 
    \mathbf{f})\), where \(\mathbf{G}\) is the genotype and \(\mathbf{f}\) is the fitness value of the individual.
  } representing candidate solutions to an optimization problem evolves towards better solutions.
  Each individual is defined by its location in the search space, known as its \emph{genotype}\footnote{
    \emph{Genotype:} Representation of the full genetic information of a candidate solution to a given optimization problem. Formally, a 
    genotype is a matrix \(\mathbf{G} = (\textbf{c}_1, \textbf{c}_2, \dots, \textbf{c}_n)\), where \(\textbf{c}_i\) is a chromosome.
  }, and its fitness value, 
  computed by a \emph{fitness function}.
  At a high level, GA is an automatic method for problem-solving, starting from
  a \textit{high-level statement} of the desired outcome, without needing the
  user to predefine the solution's form or structure.

  The classical GA operates as follows:

  \begin{code}{Genetic algorithm}{label={src:bg:ga:ga}}{kotlin}
    var population = initialize population  // Creates a random population of individuals
    population.forEach { it -> evaluate it }  // Calculates the fitness of each individual
    while (termination condition is not met) {  // Could be a pre-defined number of generations, a desired fitness level, etc.
        val survivors = select survivors from population // Selects individuals for the next generation
        val parents = select parents from population // Selects a subset of individuals as parents
        val offspring = alter parents // Applies genetic operators to parents to create new individuals
        offspring.forEach { it -> evaluate it } // Calculates the fitness of each new individual
        population = survivors + offspring // Creates the next generation
    }
    return fittest from population  // Returns the most fit individual
  \end{code}

  The exact implementation of each of these steps depends on the specific problem at hand. Factors such as the 
  problem's complexity, the representation of individuals, or even the computational resources available, can greatly 
  influence the choice of methods used for initialization, selection, alteration, and survivor selection.

  \subimport{./}{Representation.tex}
  \subimport{./}{Initialization.tex}
  \subimport{./}{Selection.tex}
  \subimport{./variation/}{_variation.index.tex}
  \subimport{./}{Termination.tex}
