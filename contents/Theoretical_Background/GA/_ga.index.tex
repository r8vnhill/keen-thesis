\section{Genetic Algorithms}
\label{sec:bg:ga}
  Genetic Algorithms (GA)\footnote{
    Also known as Simple Genetic Algorithms (SGA) 
    \autocite{yuIntroductionEvolutionaryAlgorithms2010}, or Traditional 
    Genetic Algorithms (TGA)~\autocite{shiffmanNatureCode2012}.
  }~\autocite{hollandAdaptationNaturalArtificial1992a,kozaGeneticProgrammingProgramming1992a,yuIntroductionEvolutionaryAlgorithms2010,shiffmanNatureCode2012}
  are a type of EA where a \emph{population} of \emph{individuals}\footnote{
    See \vref{def:individual}.
  } representing candidate solutions to an optimization problem evolves towards 
  better solutions.
  Each individual is defined by its location in the search space, known as its
  \emph{genotype}\footnote{See \vref{def:genotype}}, and its fitness value, 
  computed by a \emph{fitness function}.
  At a high level, GA is an automatic method for problem-solving, starting from
  a \textit{high-level statement} of the desired outcome, without needing the
  user to predefine the solution's form or structure.

  The classical GA operates as follows:

  \begin{code}[Genetic algorithm]{kotlin}
    var population = initialize population // Creates a random population of individuals
    evaluate(population) // Calculates the fitness of each individual
    while (termination condition not met) { // Could be a pre-defined number of generations, a 
                                            // desired fitness level, etc.
      val survivors = select survivors(population) // Selects individuals for the next generation
      val parents = select parents(population) // Selects a subset of individuals as parents
      val offspring = alter(parents)  // Applies genetic operators to offspring, creating 
                                      // variations
      evaluate(offspring) // Calculates the fitness of each new individual
      population = survivors + offspring // Creates the next generation
    }
    return population.fittest // Returns the most fit individual
  \end{code}

  The exact implementation of each of these steps depends on the specific 
  problem at hand.
  Factors such as the problem's complexity, the representation of individuals,
  or even the computational resources available, can greatly influence the
  choice of methods used for initialization, selection, alteration, and survivor
  selection.

  \subimport{./}{Representation.tex}
  \subimport{./}{Initialization.tex}
  \subimport{./}{Selection.tex}
  \subimport{./variation/}{_variation.index.tex}
  \subimport{./}{Termination.tex}
