\subsection{Representation and Evaluation}
\label{sec:genetic_programming:representation}
  As with GAs, the representation of the individuals is one of the most 
  important aspects of a GP.
  The representation is the encoding of potential solutions to the problem into
  a form that can be manipulated, executed and evaluated by the algorithm.

  Various methods exist for program representation, such as utilizing an abstract 
  syntax tree, a linear sequence of instructions, a stack of instructions, or a combination of these approaches.
  However, the most common representation is the \emph{tree representation}, where
  the program is represented as a composite data structure like the one shown in
  the introduction to this section.

  Let's consider the following problem: given a set of \(n\) points in the 
  plane, find the curve that best fits the points.
  This is a very common problem in statistics, and it is known as the
  \emph{symbolic regression} 
  problem~\autocite{kozaGeneticProgrammingProgramming1992a}.
  In this instance, we aim to conduct a symbolic regression of the function

  \begin{equation}
    f(x) = 5x^3 - 2x^2 + \sin(x) - 7;\; x \in [-1, 1]
  \end{equation}

  using this function, we can generate a set of random points in the curve as
  shown in \vref{fig:genetic_programming:representation:points} and 
  \vref{tab:genetic_programming:representation:points}.

  The next step would be to define the primitive set, that is the set of
  functions and terminals that will be used to build the programs.
  In this case, we will use the following set of functions and terminals:

  \begin{itemize}
    \item Functions:
      \begin{enumerate*}%[label=(\roman*)]
        \item \(+\) (Addition)
        \item \(-\) (Subtraction)
        \item \(\times\) (Multiplication)
        \item \(/\) (Division)
        \item \(\sin\) (Sine)
        \item \(\cos\) (Cosine)
        \item \(\exp\) (Exponential)
        \item \(\log\) (Logarithm)
      \end{enumerate*}
    \item Terminals:
      \begin{enumerate*}
        \item \(x\) (The variable \(x\))
        \item \(c \in 1 \dots 7\) (An ephemeral constant\footnote{
            See \vref{def:ephemeral_constant}.
          })
      \end{enumerate*}
  \end{itemize}

  \begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth]{img/theoretical_framework/symbolic.png}
    \caption{
      A set of points generated from the function \(5x^3 - 2x^2 + \sin(x) - 7\)
    }
    \label{fig:genetic_programming:representation:points}
  \end{figure}

  \begin{table}[ht!]
    \centering
    \begin{tabular}{|r|r|}
      \hline
      \(x\) & \(y\) \\
      \hline
      \hline
      -0.889\,160    & -12.872\,628 \\
      \hline
      -0.856\,103   & -12.358\,361 \\
      \hline
      -0.821\,295   & -11.851\,004 \\
      \hline
      -0.818\,193   & -11.807\,452 \\
      \hline
      -0.429\,859   & -8.183\,442  \\
      \hline
      -0.352\,328   & -7.812\,033  \\
      \hline
      -0.035\,776   & -7.038\,557  \\
      \hline
      0.017\,450  & -6.983\,134  \\
      \hline
      0.529\,010    & -6.314\,804 \\
      \hline
      0.821\,101    & -4.848\,557  \\
      \hline
    \end{tabular}
    \caption{
      A set of points generated from the function \(5x^3 - 2x^2 + \sin(x) - 7\)
    }
    \label{tab:genetic_programming:representation:points}
  \end{table}

  Using this set of functions and terminals, we can represent the program as a
  tree, as shown in \vref{fig:genetic_programming:representation:tree}.

  \begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth]{img/theoretical_framework/Expected Expression Tree.png}
    \caption{
      A tree representation of the program \(5x^3 - 2x^2 + \sin(x) - 7\)
    }
    \label{fig:genetic_programming:representation:tree}
  \end{figure}

  Note that this definition arises the possibility of having a program that
  has an infinite number of nodes, as the tree can grow indefinitely.
  This leads the search to be infinite, and thus, the algorithm will never
  find a solution.
  To  avoid this, we need to define \emph{constraints} on the generation of the
  trees.
  The most common constraints are the \emph{maximum height} of the tree and the
  \emph{maximum number of nodes} in the tree.

  Using this representation, we can define the \emph{genotype} of the
  individuals to contain only one \emph{chromosome} which is composed of a
  single \emph{gene}\footnote{%
    Although the most common representation is to have a single gene referencing
    the root of the tree, several variations that use multi-gene chromosomes
    have been proposed, such as Koza's \textit{Automatically Defined 
    Functions}~\autocite{kozaGeneticProgrammingII1994}, Angeline and Pollack's 
    \textit{Genetic Library Builder}~\autocite{peterjangelineEvolutionaryInductionSubroutines1992,peterj.angelineGeneticProgrammingEmergent1994},
    or Rosca and Ballard's \textit{Adaptive Representation}~\autocite{roscaLearningAdaptingRepresentations1994}.
  } that is the tree representation of the program.
  Recalling the definition of cardinality presented in
  \vref{def:cardinality_of_the_search_space}, we can see that the cardinality of
  the search space will be the number of possible trees that can be generated
  using the primitive set and the maximum height of the tree.

  From this lemma, arises the problem of calculating the number of trees of
  height \(H\) for a given set of terminal and function nodes.
  This problem is solved by the following theorem.

  \begin{lemma}
  \label{thm:genetic_programming:representation:cardinality}
    Let \(\mathbb{T}_{H}\) be the set of all possible \textbf{labeled trees} of
    height \(H\), with \(H \in \mathbb{N}\).
    Given the sets \(\mathcal{T}\) and \(\mathcal{F}\) corresponding to the
    possible labels of terminal nodes (nodes that do not have children) and the
    possible labels of internal nodes (nodes that have children) respectively,
    the number of trees in \(\mathbb{T}_{H}\) is given by the following
    recurrence relation:

    % TODO: Check if this is correct (it's not considering the number of
    %       trees of height H-1 that end on only terminal nodes)
    \begin{equation}
      \label{eq:genetic_programming:representation:cardinality}
      |\mathbb{T}_{H}(\mathcal{T},\, \mathcal{F})| = \begin{cases}
        |\mathcal{T}| & \text{if } H = 0 \\
        \sum_{f \in \mathcal{F}} \prod_{i=1}^{A(f)} |\mathbb{T}_{H-1}(\mathcal{T},\, \mathcal{F})| & \text{if } H > 0
      \end{cases}
    \end{equation}
  \end{lemma}

  \begin{lemma}
    Let \(\mathbb{T}_{\leq H}\) be the set of all possible \textbf{labeled 
    trees} of height \(h \leq H\), with \(H \in \mathbb{N}\) and \(h \in 
    \mathbb{N}\).
    Given the sets \(\mathcal{T}\) and \(\mathcal{F}\) corresponding to the
    possible labels of terminal nodes (nodes that do not have children) and the 
    possible labels of internal nodes (nodes that have children) respectively,
    the number of trees in \(\mathbb{T}_{\leq H}\) is given by the following
    recurrence relation:

    \begin{equation}
      \label{eq:genetic_programming:representation:cardinality}
      |\mathbb{T}_{\leq H}(\mathcal{T},\, \mathcal{F})| = \begin{cases}
        |\mathcal{T}| 
          & \text{if } H = 0 \\
        |\mathbb{T}_{H}(\mathcal{T},\, \mathcal{F})| 
            + |\mathbb{T}_{\leq H - 1}(\mathcal{T},\, \mathcal{F})|
          & \text{if } H > 0
      \end{cases}
    \end{equation}

    Where \(\mathbb{T}_{H}\) is the set of all possible trees of height \(H\).
  \end{lemma}

  \begin{proof}
    The proof is by induction on \(H\).
    For the sake of simplicity, we will use the notation
    \(|\mathbb{T}_{\leq H}| = |\mathbb{T}_{\leq H}(\mathcal{T},\, \mathcal{F})|\)
    and \(|\mathbb{T}_{H}| = |\mathbb{T}_{H}(\mathcal{T},\, \mathcal{F})|\).

    \paragraph{Base case: \(H = 0\)}
    In this case, the only possible tree is the one that has a single node,
    which is a terminal node.
    Therefore, 
    
    \[
      |\mathbb{T}_{\leq 0}| = |\mathbb{T}_{0}| = |\mathcal{T}|
    \]

    \paragraph{Inductive step}
    Let the statement be true for \(H = h\), with \(h \in \mathbb{N}\).
    We will prove that the statement is also true for \(H = h + 1\).
    Given the set \(|\mathbb{T}_{\leq h + 1}|\), we can divide it into two
    subsets: the trees of height \(h + 1\) ,\(\mathbb{T}_{h + 1}\), and the
    trees of height less than \(h + 1\). \(\mathbb{T}_{\leq h + 1 - 1} = 
    \mathbb{T}_{\leq h}\).
    It should be clear that \(\mathbb{T}_{h + 1} \cup \mathbb{T}_{\leq h} = 
    \mathbb{T}_{\leq h + 1}\), and that \(\mathbb{T}_{h + 1} \cap 
    \mathbb{T}_{\leq h} = \emptyset\).
    
    Then, the cardinality of \(\mathbb{T}_{\leq h + 1}\) is given by the
    cardinality of \(\mathbb{T}_{h + 1}\) plus the cardinality of
    \(\mathbb{T}_{\leq h}\).

    \[
      |\mathbb{T}_{\leq h + 1}| = |\mathbb{T}_{h + 1}| + |\mathbb{T}_{\leq h}|
    \]

    By the inductive hypothesis, we know that \(|\mathbb{T}_{\leq h}| =
    |\mathbb{T}_{h}| + |\mathbb{T}_{\leq h - 1}|\).
    Therefore, we can substitute the cardinality of \(\mathbb{T}_{\leq h}\) in
    the previous equation.

    \[
      |\mathbb{T}_{\leq h + 1}|
        = |\mathbb{T}_{h + 1}| + |\mathbb{T}_{h}| + |\mathbb{T}_{\leq h - 1}|
        = |\mathbb{T}_{h + 1}| + |\mathbb{T}_{h}| + |\mathbb{T}_{h - 1}|
          + |\mathbb{T}_{\leq h - 2}|
    \]

    We can continue this process until we reach the base case, where the
    cardinality of \(\mathbb{T}_{\leq 0}\) is equal to the cardinality of
    \(\mathbb{T}_{0}\).

    \[
      |\mathbb{T}_{\leq h + 1}|
        = |\mathbb{T}_{h + 1}| + |\mathbb{T}_{h}| + |\mathbb{T}_{h - 1}| + 
          \dots + |\mathbb{T}_{0}|
    \]

    Therefore, we can conclude that the cardinality of 
    \(\mathbb{T}_{\leq h + 1}\) is equal to the sum of the cardinalities of
    \(\mathbb{T}_{h}\) and \(\mathbb{T}_{\leq h}\), which proves the hypothesis.

    \[
      |\mathbb{T}_{\leq h + 1}| = |\mathbb{T}_{h}| + |\mathbb{T}_{\leq h}|
    \]
  \end{proof}

  
  Now, we need to define how to evaluate the fitness of a program.
  Again, there are many ways to do this, but a common way is to use the
  \emph{mean squared error} (MSE) between the points and the program.

  \begin{definition}[Mean Squared Error]
  \label{def:mse}
    If a vector of \(n\) predictions is generated from a sample of \(n\) data
    points on all variables, and \(\mathbf{y}_i\) is the \(i\)-th observed value
    and \(\hat{\mathbf{y}}_i\) is the \(i\)-th prediction, then the MSE of the 
    predictor is a function \(\mathrm{MSE}:\: \mathbb{R}^n \times \mathbb{R}^n
    \to \mathbb{R}\) defined as:

    \begin{equation}
      \label{eq:mse}
      \mathrm{MSE}(\mathbf{y}, \hat{\mathbf{y}}) 
        = \frac{1}{n} \sum_{i=1}^{n} (\mathbf{y}_i - \hat{\mathbf{y}}_i)^2
    \end{equation}
  \end{definition}

  The MSE is a common measure of the quality of an estimator, used in many
  \textit{machine learning} problems.

  In our case, we will use the MSE to evaluate the fitness of a program.
  Consider a program \(\mathsf{P}\) and two sets of points, \(\mathbf{x}\) and 
  \(\mathbf{y}\), as outlined in 
  \vref{tab:genetic_programming:representation:points}.
  Suppose also that \(\mathsf{P}[\mathbf{x}]\) is the set of points generated
  by evaluating \(\mathsf{P}\) on the points of \(\mathbf{x}\), and that
  \(\mathsf{P}(x)\) is the result of evaluating \(\mathsf{P}\) on the point
  \(x\).
  Then, we can define the fitness of \(\mathsf{P}\) as:

  \begin{equation}
  \label{eq:genetic_programming:representation:fitness}
    \phi_\mathsf{P} = \mathrm{MSE}(\mathbf{y}, \mathsf{P}[\mathbf{x}])
      = \frac{1}{n} \sum_{i=1}^{n} (\mathbf{y}_i - \mathsf{P}(\mathbf{x}_i))^2
  \end{equation}

  This section elucidated the pivotal aspects of Genetic Programming (GP), 
  focusing on representation of individuals and their evaluation.
  Individuals, potential solutions to a problem, can be encoded in several ways
  including tree representation.
  A common statistical problem, symbolic regression, was illustrated using a set
  of points on a curve from a function involving both polynomial and
  trigonometric elements.
  By defining a set of functions and terminals, these points were represented as
  a tree.
  The fitness of an individual program was assessed using the Mean Squared Error
  (MSE) between the points on the curve generated by the function and the points
  produced by the program.
  Thus, in the context of this problem, the fittest individual is the one that
  minimizes this error, i.e., best fits the curve.
  The methods described here underscore the versatility and applicability of GP
  to various types of problems.
  This method of representation and evaluation provides a robust basis for
  generating evolving populations of programs. 
  In the next sections we will discuss the mechanisms for generating these
  populations and the evolutionary operators that act on them.
