\section{Jenetics: Java Genetic Algorithm Library}
\label{sec:sota:\textit{jenetics}}

  \emph{Jenetics}~\autocite{wilhelmstotterJeneticsJavaGenetica} is a robust
  EC library developed in \textit{Java}.
  It is a comprehensive framework that provides a \textit{wide range} of genetic
  algorithms and operators.
  The library is open-source and available under the \textit{MIT} 
  license~\autocite{MITLicense2006}.

  \textit{Jenetics} structure revolves around two main concepts: 
  \texttt{Phenotype}\footnote{See \vref{def:phenotype}} and \texttt{Engine}.
  The \texttt{Phenotype} is a representation of a single candidate solution to
  a given optimization problem.
  Meanwhile, the \texttt{Engine} is the core of the library, which controls the
  evolution process.
  It is responsible for the initialization of the population, the execution of
  the evolution, and the termination of the evolution once the termination
  condition is met (this uses a very similar approach to the one we presented 
  in \vref{sec:sota:pharo}).

  Onr thing that sets \textit{Jenetics} apart from other libraries is the use 
  of the \textit{Java's Stream API}~\autocite{StreamJavaPlatform} to make a 
  seamless integration between it and the \texttt{EvolutionStream} class used 
  by the \texttt{Engine}.
  This means that the evolution has access to all the features provided by the
  Stream API, such as parallelization, filtering, and mapping.

  Below, we demonstrate the use of \textit{Jenetics} to solve the OMP with a 
  genetic algorithm:

  % \begin{src}
  %   \captionof{listing}{A simple genetic algorithm using \textit{Jenetics}}
  %   \label{src:sota:jenetics:example}
  %   \begin{minted}[linenos]{java}
  %     public class OneMax {
  %       public static void main(String[] args) {
  %         RandomRegistry.random(new Random(11));
  %         final var engine =
  %             Engine.builder((Genotype<BitGene> gt) ->
  %                               gt.chromosome().as(BitChromosome.class).bitCount(),
  %                           BitChromosome.of(20, 0.5))
  %                   .maximizing()
  %                   .populationSize(20)
  %                   .alterers(new Mutator<>(0.05), new SinglePointCrossover<>(0.5))
  %                   .build();
  %         Phenotype<BitGene, Integer> best = engine.stream()
  %                                                  .limit(Limits.byFitnessThreshold(19))
  %                                                  .collect(EvolutionResult.toBestPhenotype());
  %         System.out.println("Target fitness reached at generation: " + best.generation());
  %         System.out.println("Best individual is: " + best.genotype());
  %         System.out.println("with fitness: " + best.fitness());
  %       }
  %     }
  %   \end{minted}
  % \end{src}

  When executed, the program outputs the following:

  \begin{minted}{text}
    Target fitness reached at generation: 40
    Best individual is: [00001111|11111111|11111111]
    with fitness: 20
  \end{minted}

  This example demonstrates \textit{Jenetics}' usage for implementing a straightforward
  genetic algorithm, with the added ability to stop evolution once steady
  fitness is achieved.

  Here is an explanation of the code:

  \begin{enumerate}
    \item[1-2] First, a class containing a \texttt{main} method is established.
      This forms the launching point of the program.
    \item[3] The \texttt{RandomRegistry} is then utilized to preset the random 
      seed, a step that ensures consistency and replicability of program 
      outputs.
    \item[4-11] The core configuration of the evolutionary engine occurs next, 
      tailored specifically to the problem at hand.
      \begin{enumerate}
        \item[5-7] An \texttt{Engine} is instantiated using the 
          \texttt{Engine.builder} method, requiring two arguments: a 
          \texttt{Function} and a \texttt{Genotype}.
          The \texttt{Function} assesses the fitness of a \texttt{Genotype} by 
          tallying the quantity of \texttt{1}s in the \texttt{Genotype}.
          A \texttt{Genotype} is created via the \texttt{BitChromosome.of} 
          method, which mandates the \texttt{length} of the chromosome and the 
          \texttt{probability} of a \texttt{1} appearing within the chromosome.
          Here, \texttt{BitChromosome} is a distinct version of the 
          \texttt{Chromosome} interface, used to depict a \texttt{Genotype} 
          composed of \texttt{BitGene}s.
        \item[8] The \texttt{maximizing} method signals that the objective is 
          to boost fitness to its maximum possible value.
        \item[9] The \texttt{populationSize} method sets the size of the 
          evolutionary population.
        \item[10] The \texttt{alterers} method sets the genetic operations to 
          be used in the evolution.
          Here, the \texttt{Mutator} and \texttt{SinglePointCrossover} are 
          selected.
          The \texttt{Mutator} behaves similarly to a \textit{bit-flip 
          mutation} operator in this context.
        \item[11] Finally, the \texttt{build} method assembles the functional 
          \texttt{Engine}.
      \end{enumerate}
    \item[12-14] Execution of the evolution process follows.
      \begin{enumerate}
        \item[12] The \texttt{stream} method generates an 
          \texttt{EvolutionStream} from the \texttt{Engine}, allowing for 
          control over the evolution process.
        \item[13] The \texttt{limit} method sets the termination condition.
          The evolution halts once a \texttt{Phenotype} possessing a fitness 
          \textbf{exceeding} 19 is located.
        \item[14] Lastly, the \texttt{collect} method gathers the evolution's 
          output, in this case, capturing the optimal \texttt{Phenotype} 
          discovered.
      \end{enumerate}
    \item[15-17] The final stage involves printing the evolution results to the 
      console for review and analysis.
  \end{enumerate}

  This example showcases the key aspects of using \textit{Jenetics}: creating 
  genotypes, setting up an engine, and controlling the evolution process.

  \textit{Jenetics} provides extensive support for multi-objective algorithms 
  and parallel execution, which are common necessities in intricate optimization
  problems.

  As one of the most comprehensive and state-of-the-art genetic algorithm
  libraries available today, \textit{Jenetics} enjoys widespread acclaim.
  Nonetheless, some facets of \textit{Jenetics} may pose challenges for users.

  \begin{itemize}
    \item Since it is a Java library, \textit{Jenetics} inherits some of the
      language's shortcomings, such as verbosity and complexity.
    \item The library's documentation is not comprehensive, and some of the
      examples are outdated, or even exist multiple implementations of the same
      example.
    \item The lack of documentation proper documentation is reflected in line 3
      of the example, where the \texttt{RandomRegistry} is used to set the
      random seed.
      This is meant to ensure the replicability of the program's output, 
      according to the documentation, but executing the program shows that this
      does not work.
      This could be solved by providing complete code samples, but reviewing the
      documentation it is common to find code snippets that are not complete,
      with missing assignments (depicted by the common use of \texttt{...} in 
      the code samples), or by not giving concrete use cases of the library's
      features.
    \item A balance exists between the framework's flexibility and its ease of
      use.
      While \textit{Jenetics}' adaptability is commendable, it heavily relies
      on builders and factories, which in occasions can make the code more
      complex and difficult to understand.
    \item \textit{Java}'s lack of proper type inference can make the code more
      verbose than necessary.
      This is particularly noticeable when using classes such as
      \texttt{Phenotype}, which require the specification of multiple type
      parameters.
    \item To maintain efficiency, \textit{Jenetics} leans on the Java Stream 
      API for parallelization, this is not a standard approach in the field of
      evolutionary computation, and it may be difficult to understand for
      newcomers.
      Additionally, the use of the Stream API may lead to difficult to debug
      code, since the execution of the code is mostly handled by the 
      \textit{Java} standard library.
      In addition, the use of the Stream API depends on the use of deferred
      execution, even when executing the code sequentially.
    \item \textit{Jenetics} is parallel by default, this may negatively impact
      the performance of the program when running on small populations or
      problems with a small number of variables, since the overhead of
      parallelization may be greater than the benefits of parallel execution.
    \item When solving complex problems the code quickly becomes complicated
      with the introduction of \textit{codecs}, \textit{proxies}, and the 
      \texttt{Problem} interface.
    \item \textit{Jenetics} heavily relies on the use of features not present in
      \textit{Java}'s standard library, in particular, immutable data.
      This increases the learning curve for newcomers.
    \item \textit{Jenetics} depends on newer versions of \textit{Java}, which
      may be a problem for users that are not able to update their version of
      \textit{Java} (this problem becomes more relevant when considering that
      most \textit{Android} devices do not support newer versions of
      \textit{Java})
  \end{itemize}

  Despite these shortcomings, \textit{Jenetics} is a powerful and flexible
  library that can be used to solve a wide variety of optimization problems.
  The library is actively maintained, and it is one of the most popular
  evolutionary computation libraries available today.
