\section{Jenetics: Java Genetic Algorithm Library}
\label{sec:sota:jenetics}

  \emph{Jenetics}~\autocite{wilhelmstotterJeneticsJavaGenetica} is a robust
  EC library developed in \textit{Java}.
  It is a comprehensive framework that provides a \textit{wide range} of genetic
  algorithms and operators.
  The library is open-source and available under the \textit{MIT} 
  license~\autocite{MITLicense2006}.

  \textit{Jenetics} structure revolves around two main concepts: 
  \texttt{Phenotype}\footnote{See \vref{def:phenotype}} and \texttt{Engine}.
  The \texttt{Phenotype} is a representation of a single candidate solution to
  a given optimization problem.
  Meanwhile, the \texttt{Engine} is the core of the library, which controls the
  evolution process.
  It is responsible for the initialization of the population, the execution of
  the evolution, and the termination of the evolution once the termination
  condition is met (this uses a very similar approach to the one we presented 
  in \vref{sec:sota:pharo}).

  Onr thing that sets \textit{Jenetics} apart from other libraries is the use 
  of the \textit{Java's Stream API}~\autocite{StreamJavaPlatform} to make a 
  seamless integration between it and the \texttt{EvolutionStream} class used 
  by the \texttt{Engine}.
  This means that the evolution has access to all the features provided by the
  Stream API, such as parallelization, filtering, and mapping.

  Below, we demonstrate the use of \textit{Jenetics} to solve the OMP with a 
  genetic algorithm:

  \lstinputlisting[
    language=Java, 
    caption={A simple genetic algorithm using \textit{Jenetics}},
    label={src:sota:jenetics:example}
  ]{Jenetics1.java}

  When executed, the program outputs the following:

  \begin{verbatim}
    Target fitness reached at generation: 40
    Best individual is: [00001111|11111111|11111111]
    with fitness: 20
  \end{verbatim}

  This example demonstrates \textit{Jenetics}' usage for implementing a straightforward
  genetic algorithm, with the added ability to stop evolution once steady
  fitness is achieved.

  Here is an explanation of the code:

  \begin{enumerate}
    \item[1-2] First, a class containing a \texttt{main} method is established.
      This forms the launching point of the program.
    \item[3] The \texttt{RandomRegistry} is then utilized to preset the random 
      seed, a step that ensures consistency and replicability of program 
      outputs.
    \item[4-11] The core configuration of the evolutionary engine occurs next, 
      tailored specifically to the problem at hand.
      \begin{enumerate}
        \item[5-7] An \texttt{Engine} is instantiated using the 
          \texttt{Engine.builder} method, requiring two arguments: a 
          \texttt{Function} and a \texttt{Genotype}.
          The \texttt{Function} assesses the fitness of a \texttt{Genotype} by 
          tallying the quantity of \texttt{1}s in the \texttt{Genotype}.
          A \texttt{Genotype} is created via the \texttt{BitChromosome.of} 
          method, which mandates the \texttt{length} of the chromosome and the 
          \texttt{probability} of a \texttt{1} appearing within the chromosome.
          Here, \texttt{BitChromosome} is a distinct version of the 
          \texttt{Chromosome} interface, used to depict a \texttt{Genotype} 
          composed of \texttt{BitGene}s.
        \item[8] The \texttt{maximizing} method signals that the objective is 
          to boost fitness to its maximum possible value.
        \item[9] The \texttt{populationSize} method sets the size of the 
          evolutionary population.
        \item[10] The \texttt{alterers} method sets the genetic operations to 
          be used in the evolution.
          Here, the \texttt{Mutator} and \texttt{SinglePointCrossover} are 
          selected.
          The \texttt{Mutator} behaves similarly to a \textit{bit-flip 
          mutation} operator in this context.
        \item[11] Finally, the \texttt{build} method assembles the functional 
          \texttt{Engine}.
      \end{enumerate}
    \item[12-14] Execution of the evolution process follows.
      \begin{enumerate}
        \item[12] The \texttt{stream} method generates an 
          \texttt{EvolutionStream} from the \texttt{Engine}, allowing for 
          control over the evolution process.
        \item[13] The \texttt{limit} method sets the termination condition.
          The evolution halts once a \texttt{Phenotype} possessing a fitness 
          \textbf{exceeding} 19 is located.
        \item[14] Lastly, the \texttt{collect} method gathers the evolution's 
          output, in this case, capturing the optimal \texttt{Phenotype} 
          discovered.
      \end{enumerate}
    \item[15-17] The final stage involves printing the evolution results to the 
      console for review and analysis.
  \end{enumerate}

  This example showcases the key aspects of using \textit{Jenetics}: creating 
  genotypes, setting up an engine, and controlling the evolution process.

  \textit{Jenetics} provides extensive support for multi-objective algorithms 
  and parallel execution, which are common necessities in intricate optimization
  problems.

  Recognized as one of the most comprehensive and cutting-edge genetic algorithm libraries today, \textit{Jenetics} receives wide-ranging acclaim. However, certain aspects of \textit{Jenetics} could be challenging for its users.

  \begin{itemize}
    \item As a Java library, \textit{Jenetics} unavoidably incorporates some of Java's limitations, notably its verbosity and complexity.
    \item The library's documentation could be more comprehensive. Currently, some examples are outdated or have redundant implementations.
    \item The insufficient documentation is most evident in the use of the \texttt{RandomRegistry} to set the random seed, as seen in example line 3. The documentation claims this ensures the replicability of the program's output, but practical execution proves otherwise. More complete code samples and concrete use cases would ameliorate this issue.
    \item There is a delicate balance between the framework's flexibility and its usability. \textit{Jenetics}' notable adaptability leans heavily on builders and factories, which can occasionally obfuscate the code.
    \item Java's lack of robust type inference can lead to verbosity, particularly evident when using classes like \texttt{Phenotype} requiring multiple type parameters.
    \item \textit{Jenetics} relies on the Java Stream API for parallelization to maintain efficiency. However, this approach is not typical in the field of evolutionary computation, making it challenging for beginners. Furthermore, the use of the Stream API can result in difficult-to-debug code due to the execution mainly handled by Java's standard library.
    \item By default, \textit{Jenetics} operates in parallel. This can detrimentally affect program performance when working on small populations or problems with fewer variables due to parallelization's overhead.
    \item Complex problem-solving with \textit{Jenetics} can quickly complicate the code, introducing \textit{codecs}, \textit{proxies}, and the \texttt{Problem} interface.
    \item \textit{Jenetics} extensively employs features not found in Java's standard library, particularly immutable data, thereby steepening the learning curve for beginners.
    \item \textit{Jenetics} is compatible with newer versions of Java, potentially problematic for users unable to update their Java version. This issue is especially relevant for most Android devices, which do not support newer Java versions.
    \item There's a lack of a robust mechanism for visualizing the evolution process, a feature commonly found in other evolutionary computation libraries.
    \item \textit{Jenetics} isn't entirely type-safe, necessitating explicit casts via the \texttt{as} method.
  \end{itemize}

  Despite these shortcomings, \textit{Jenetics} is a powerful and flexible
  library that can be used to solve a wide variety of optimization problems.
  The library is actively maintained, and it is one of the most popular
  evolutionary computation libraries available today.
