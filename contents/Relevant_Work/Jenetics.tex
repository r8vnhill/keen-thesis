\section{Jenetics: Java Genetic Algorithm Library}
\label{sec:sota:jenetics}

  \emph{Jenetics}~\autocite{wilhelmstotterJeneticsJavaGenetica} is a robust
  EC library developed in \textit{Java}.
  It is a comprehensive framework that provides a \textit{wide range} of genetic
  algorithms and operators.
  The library is open-source and available under the \textit{MIT} 
  license~\autocite{MITLicense2006}.

  \textit{Jenetics} structure revolves around two main concepts: 
  \texttt{Phenotype}\footnote{See \vref{def:phenotype}} and \texttt{Engine}.
  The \texttt{Phenotype} is a representation of a single candidate solution to
  a given optimization problem.
  Meanwhile, the \texttt{Engine} is the core of the library, which controls the
  evolution process.
  It is responsible for the initialization of the population, the execution of
  the evolution, and the termination of the evolution once the termination
  condition is met (this uses a very similar approach to the one we presented 
  in \vref{sec:sota:pharo}).

  One thing that sets \textit{Jenetics} apart from other libraries is the use 
  of the \textit{Java's Stream API}~\autocite{StreamJavaPlatform} to make a 
  seamless integration between it and the \texttt{EvolutionStream} class used 
  by the \texttt{Engine}.
  This means that the evolution has access to all the features provided by the
  Stream API, such as parallelization, filtering, and mapping.

  Below, we demonstrate the use of \textit{Jenetics} to solve the OMP with a 
  genetic algorithm:

  \begin{code}*{Solution to the OMP using \textit{Jenetics}}{
    label=lst:sota:jenetics:omp
  }{java}
    public class OneMax {
      public static void main(String[] args) {
        RandomRegistry.random(new Random(11));
        final var engine =
            Engine.builder((Genotype<BitGene> gt) ->
                              gt.chromosome().as(BitChromosome.class).bitCount(),
                          BitChromosome.of(20, 0.5))
                  .maximizing()
                  .populationSize(20)
                  .alterers(new Mutator<>(0.05), new SinglePointCrossover<>(0.5))
                  .build();
        Phenotype<BitGene, Integer> best = engine.stream()
                                                .limit(Limits.byFitnessThreshold(19))
                                                .collect(EvolutionResult.toBestPhenotype());
        System.out.println("Target fitness reached at generation: " + best.generation());
        System.out.println("Best individual is: " + best.genotype());
        System.out.println("with fitness: " + best.fitness());
      }
    }
  \end{code}

  When executed, the program outputs the following:

  \begin{verbatim}
    Target fitness reached at generation: 40
    Best individual is: [00001111|11111111|11111111]
    with fitness: 20
  \end{verbatim}

  This example demonstrates \textit{Jenetics}' usage for implementing a 
  straightforward
  genetic algorithm, with the added ability to stop evolution once steady
  fitness is achieved.

  Here is an explanation of the code:

  \begin{enumerate}
    \item[1-2] First, a class containing a \texttt{main} method is established.
      This forms the launching point of the program.
    \item[3] The \texttt{RandomRegistry} is then utilized to preset the random 
      seed, a step that ensures consistency and replicability of program 
      outputs.
    \item[4-11] The core configuration of the evolutionary engine occurs next, 
      tailored specifically to the problem at hand.
      \begin{enumerate}
        \item[5-7] An \texttt{Engine} is instantiated using the 
          \texttt{Engine.builder} method, requiring two arguments: a 
          \texttt{Function} and a \texttt{Genotype}.
          The \texttt{Function} assesses the fitness of a \texttt{Genotype} by 
          tallying the quantity of \texttt{1}s in the \texttt{Genotype}.
          A \texttt{Genotype} is created via the \texttt{BitChromosome.of} 
          method, which mandates the \texttt{length} of the chromosome and the 
          \texttt{probability} of a \texttt{1} appearing within the chromosome.
          Here, \texttt{BitChromosome} is a distinct version of the 
          \texttt{Chromosome} interface, used to depict a \texttt{Genotype} 
          composed of \texttt{BitGene}s.
        \item[8] The \texttt{maximizing} method signals that the objective is 
          to boost fitness to its maximum possible value.
        \item[9] The \texttt{populationSize} method sets the size of the 
          evolutionary population.
        \item[10] The \texttt{alterers} method sets the genetic operations to 
          be used in the evolution.
          Here, the \texttt{Mutator} and \\\texttt{SinglePointCrossover} are 
          selected.
          The \texttt{Mutator} behaves similarly to a \textit{bit-flip 
          mutation} operator in this context.
        \item[11] Finally, the \texttt{build} method assembles the functional 
          \texttt{Engine}.
      \end{enumerate}
    \item[12-14] Execution of the evolution process follows.
      \begin{enumerate}
        \item[12] The \texttt{stream} method generates an 
          \texttt{EvolutionStream} from the \texttt{Engine}, allowing for 
          control over the evolution process.
        \item[13] The \texttt{limit} method sets the termination condition.
          The evolution halts once a \texttt{Phenotype} possessing a fitness 
          \textbf{exceeding} 19 is located.
        \item[14] Lastly, the \texttt{collect} method gathers the evolution's 
          output, in this case, capturing the optimal \texttt{Phenotype} 
          discovered.
      \end{enumerate}
    \item[15-17] The final stage involves printing the evolution results to the 
      console for review and analysis.
  \end{enumerate}

  This example showcases the key aspects of using \textit{Jenetics}: creating 
  genotypes, setting up an engine, and controlling the evolution process.

  \textit{Jenetics} provides extensive support for multi-objective algorithms 
  and parallel execution, which are common necessities in intricate optimization
  problems.

  Recognized as one of the most comprehensive and cutting-edge genetic 
  algorithm libraries today, \textit{Jenetics} receives wide-ranging acclaim. 
  However, certain aspects of \textit{Jenetics} could be challenging for its 
  users.

  \begin{itemize}
    \item \textbf{Java Limitations:} \textit{Jenetics} is hindered by Java's 
      verbosity and complexity.
      As a Java library, \textit{Jenetics} unavoidably incorporates some of 
      Java's limitations, notably its verbosity and complexity.
    \item \textbf{Documentation Gaps:} The library's documentation is not 
      exhaustive and sometimes outdated.
      The library's documentation could be more comprehensive. Currently, some 
      examples are outdated or have redundant implementations.
    \item \textbf{Seed Replicability:} The \texttt{RandomRegistry}'s claim on 
      replicability conflicts with actual outcomes, indicating a documentation 
      deficiency.
      The insufficient documentation is most evident in the use of the 
      \texttt{RandomRegistry} to set the random seed, as seen in example line 
      3.
      The documentation claims this ensures the replicability of the program's 
      output, but practical execution proves otherwise.
      More complete code samples and concrete use cases would ameliorate this 
      issue.
    \item \textbf{Flexibility vs. Usability:} \textit{Jenetics} offers 
      adaptability but leans on builders and factories, sometimes obscuring the 
      code.
      There is a delicate balance between the framework's flexibility and its 
      usability. \textit{Jenetics}' notable adaptability leans heavily on 
      builders and factories, which can occasionally obfuscate the code.
    \item \textbf{Complex Problem Handling:} Addressing intricate problems in 
      \textit{Jenetics} introduces multiple complexities in the code.
      Complex problem-solving with \textit{Jenetics} can quickly complicate the 
      code, introducing \textit{codecs}, \textit{proxies}, and the 
      \texttt{Problem} interface.
    \item \textbf{Visualization Gap:} The library lacks a comprehensive   
      mechanism for visualizing the evolutionary process.
      There's a lack of a robust mechanism for visualizing the evolution 
      process.
    \item \textbf{Well typed Jenetics programs can raise errors on runtime:} 
      \textit{Jenetics} sometimes requires explicit type casting, which introduces errors at runtime.
  \end{itemize}

  Despite these shortcomings, \textit{Jenetics} is a powerful and flexible
  library that can be used to solve a wide variety of optimization problems.
  The library is actively maintained, and it is one of the most popular
  evolutionary computation libraries available today.
