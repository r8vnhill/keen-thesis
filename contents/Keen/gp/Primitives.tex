% Copyright (c) 2023 Ignacio Slater Muñoz All rights reserved.
% Use of this source code is governed by a BSD-style
% license that can be found in the LICENSE file.

\subsection{Primitive Set}
\label{sec:keen:gp:primitives}
  The quintessential component of any GP implementation is the set of
  \textit{primitives} that define the language of the GP system. The
  \textit{Keen} framework's GP implementation is no exception, and its
  primitives are defined in the \texttt{prog} package.

  The \texttt{prog} package exposes three main components: \emph{reduceable}
  expressions, \emph{program} trees, and \emph{generator} functions.

  \subsubsection{Reduceable Expressions}
    Within the \textit{Keen} framework, "reduceable expressions" serve as the 
    building blocks for creating more complex mathematical or logical 
    constructs. Primitives in \textit{Keen} are captured using the 
    \texttt{Reduceable} interface. This interface outlines a single method, 
    \texttt{invoke}, which accepts a list of arguments and yields a single 
    value. Drawing parallels, the \texttt{invoke} method resembles a function 
    call, and the \texttt{Reduceable} interface stands as a function signature.
  
    The architecture of the proposed \texttt{Reduceable} interface can be 
    appreciated in \vref{lst:sec:keen:gp:primitives:reduce}.

    \begin{code}{
      The \texttt{Reduceable} interface
    }{
      label=lst:sec:keen:gp:primitives:reduce
    }{kotlin}
      interface Reduceable<T> : Node<Reduceable<T>> {
          operator fun invoke(args: List<T>): T
      }      
    \end{code}

    It's essential to underline that the \texttt{Reduceable} interface is an 
    extension of \texttt{Node<Reduceable<T>>}. This inherently implies that any 
    reduceable expression is also a node within an expression tree. Such an 
    arrangement forms a cornerstone of \textit{Keen}'s Genetic Programming (GP) 
    approach as it lays the foundation for generating expressions of arbitrary 
    intricacy.

    Venturing forward, \textit{Keen} subdivides the \texttt{Reduceable} into 
    two primitive subsets: terminals and functions. The former, terminals, 
    embody reduceable expressions that act as leaf nodes in an expression tree. 
    Conversely, functions serve as reduceable expressions that denote 
    intermediate nodes in said tree.

    \begin{code}{Prototype of the \texttt{Terminal} interface}{
      label=lst:sec:keen:gp:primitives:terminal
    }{kotlin}
      interface Terminal<T> : Reduceable<T>, Leaf<Reduceable<T>> {
          fun create(): Terminal<T>
          override val arity: Int
              get() = 0
      }
    \end{code}

    \begin{code}{Prototype of the \texttt{Fun} open class}{
      label=lst:sec:keen:gp:primitives:fun
    }{kotlin}
      open class Fun<T>(
          private val name: String,
          override val arity: Int,
          private val body: (List<T>) -> T
      ) : Reduceable<T>, Intermediate<Reduceable<T>> {
          override fun invoke(args: List<T>) = body(args)
      }
    \end{code}

    Note that both the \texttt{Terminal} interface and the \texttt{Fun} class
    are parameterized by a type \texttt{T}. This type represents the return
    type of the \texttt{invoke} method, and is used to enforce type safety
    when creating expressions.

    A crucial aspect of our design strategy involves the employment of an open 
    class for the \texttt{Fun} class, a decision we consider more fitting than 
    resorting to an interface. Given that functions symbolize expressions with 
    an innate arbitrary behavior, architecting an interface and extending it 
    for each unique function emerges as an impractical venture. In contrast, an 
    open class stands out as a versatile choice, facilitating the crafting of 
    generic functions and paving the way for class extensions to enhance the 
    behavior of the function. This structural framework empowers users to 
    directly harness the \texttt{Fun} class for function creation or extend it 
    for more intricate functions, as exemplified in \vref{lst:app:keen_fun_add}.

  \subsubsection{Program trees}
    The \texttt{Reduceable} interface and its subsets—terminals and 
    functions—are foundational components that aid in the construction of 
    program trees in \textit{Keen}. The framework represents these program 
    trees as immutable tree structures, a design decision rooted in advantages 
    such as thread safety, predictability, and reduced chances of accidental 
    data modification, in particular, making program trees immutable one can 
    assure that the arity of a node is always correct.

    In essence, a program tree is characterized by a reduceable expression 
    situated at its root, which in turn references other programs as its 
    descendants. This design is vividly portrayed in the blueprint provided in 
    \vref{lst:sec:keen:gp:primitives:prog}.

    \begin{code}{Prototype of the \texttt{Program} class}{
      label=lst:sec:keen:gp:primitives:prog
    }{kotlin}
      class Program<V>(
        val reduceable: Reduceable<V>,
        override val children: List<Program<V>> = emptyList()
      ) : Tree<Reduceable<V>, Program<V>>, Copyable<Program<V>> {
        // ...
        operator fun invoke(vararg args: V): V = reduceable(children.map { it(*args) })
      }
    \end{code}

    The \texttt{Program} class is parameterized by a type \texttt{V}, which
    represents the return type of the \texttt{invoke} method of the
    \texttt{Reduceable} interface. This type is used to enforce type safety
    when creating program trees.
    The \texttt{invoke} function operates recursively, invoking the
    \texttt{invoke} method of the root reduceable expression, passing the
    results of the recursive invocations of its children as arguments.

    The creation of immutable trees can be tricky, especially when dealing with
    recursive structures. To address this issue, the \texttt{Tree} interface
    provides a method to create trees from a depth first traversal of a
    list of nodes. The algorithm used to create trees from a list of nodes is 
    presented in \vref{lst:sec:keen:gp:primitives:tree}.

    \begin{code}{Algorithm to create a tree from a list of nodes}{
      label=lst:sec:keen:gp:primitives:tree
    }{kotlin}
      val stack = mutableListOf<T>()
      nodes.reversed().forEach {
          val children = stack.take(it.arity)
          stack.removeAll(children.toSet())
          val node = createNode(it.value, children)
          stack.add(node)
      }
      return stack.first()
    \end{code}

    This algorithm takes a list of nodes and creates a tree by traversing the
    list in reverse order. For each node, it takes the required number of
    children from the top of the stack, removes them from the stack, and
    creates a new node with the given value and children. The algorithm
    enforces that the arity of the tree matches the arity of the node. Finally,
    it returns the top of the stack, which is the root of the tree.