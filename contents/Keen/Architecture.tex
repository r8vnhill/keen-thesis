\section{Architecture}
\label{sec:architecture}
  \textit{Keen}, our sophisticated and flexible evolutionary computation
  library, organizes its architectural blueprint into five distinguishable
  modules: \textit{Evolution}, \textit{Genetic Material},
  \textit{Genetic Operators}, \textit{Utility}, and \textit{Programs}.

  The \textit{Utility} module serves as the library's toolbox, providing various 
  auxiliary classes and functions that the remaining modules can utilize.
  As its content is primarily supplementary, it won't be thoroughly examined 
  within this document.

  The \textit{Genetic Material} module encapsulates the foundational elements 
  defining the characteristics of our evolving entities or \texttt{Individual}s.
  Its core constituents are the \texttt{Individual} and \texttt{Genotype} 
  classes, accompanied by the encompassing \texttt{Chromosome} and \texttt{Gene} 
  hierarchies.

  Within the \textit{Genetic Operators} module, we define the different genetic 
  operators that the \textit{Evolution Engine} leverages to stimulate the 
  evolutionary process.
  This module accommodates classes embodying crossover, mutation, and selection 
  operators, systematically grouped into corresponding categories: 
  \textbf{Crossover}, \textbf{Mutation}, and \textbf{Selection}.

  The \textit{Evolution} module houses classes that construct the engine of 
  evolution itself, along with essential classes promoting the smooth 
  progression of the evolution process.

  Finally, the nascent \textit{Programs} module showcases genetic programming 
  paradigms through a collection of programs developed under this concept.
  However, as it is in its preliminary stages, this document will not cover it 
  in detail.

  A majority of the \textit{Keen} classes are parameterized by the type of data 
  they handle and the gene type composing the population of individuals, like an 
  integer or an integer gene.
  This design choice lends \textit{Keen} a wide range of flexibility, enabling 
  users to tailor the genetic material for the evolution engine.
  Moreover, thanks to \textit{Kotlin}'s proficient type inference, we can 
  generally omit type parameters, thereby boosting code legibility.

  \textit{Keen} upholds the principle of immutability, rendering most of its
  classes immutable.
  This provides an assurance of robustness and predictability, as objects remain
  unaltered post-creation, enhancing parallelization potential by allowing
  shared memory use without the need for synchronization mechanisms.

  Furthermore, \textit{Keen} offers factory methods for most classes, fostering 
  an intuitive and straightforward programming experience.
  It employs language-oriented programming techniques to form a domain-specific 
  language (DSL), streamlining object creation with more readable code.
  This approach is evident in libraries such as 
  \textit{Kotlinx.html}~\autocite{KotlinxHtml2023}, 
  \textit{Kotlin Telegram Bot}~\autocite{KotlinTelegramBot2023}, and 
  \textit{Kotest}~\autocite{KotestKotesta}.
  While we promote factory methods as the primary mode of object creation, the 
  design caters to manual object creation, granting users greater control over 
  the process when needed.


  Here's an illustrative DSL example, where we create a \texttt{Genotype} for
  the \textit{Room Scheduling} problem.
  Here, each \texttt{Chromosome} represents a meeting, composed of a single
  integer gene indicating the assigned room. The full code snippet can be found 
  in \vref{lst:app:keen_room_scheduling}.

  \begin{code}{
      Usage of the \textit{Keen} Domain Specific Configuration Language 
      (KDSCL) to create a \texttt{Genotype} for the \textit{Room
      Scheduling} problem.
  }{label={lst:keen:arch:scheduling}}{kotlin}
      genotype {                  // We are creating a Genotype
          repeat(meetings.size) { // We create a Chromosome for each meeting
              chromosome {        // We create a single Chromosome
                  ints {          // We create a single integer gene
                      size = 1    // The gene is a single integer
                      // The gene can take values from 0 to the number of meetings
                      range = meetings.indices.first to meetings.indices.last
                  }
              }
          }
      }
  \end{code}

  The approach we see here closely mirrors the use of configuration files in 
  ECJ.
  However, as our DSL is defined entirely within \textit{Kotlin}, it offers 
  significant advantages.
    These include type safety, robust Integrated Development Environment (IDE) 
    support, and the ability to leverage the full capabilities of the language 
    in defining our genotypes.

    In the given example, we employed the standard \texttt{repeat} function 
    from the \textit{Kotlin} library to create a number of chromosomes equal to 
    the number of meetings.
    It is essential to note that this function is not part of our DSL but a 
    standard feature provided by the language.

    Furthermore, our approach enhances the readability of the code.
    Compared to using ECJ's configuration files, the DSL presents a more 
    intelligible and cleaner interface.
    By defining the configurations in the same language and even within the 
    same files as the rest of the code, we significantly improve code 
    readability.
    This consolidation offers a more streamlined, unified development 
    environment that facilitates easier understanding and manipulation of the 
    codebase.

    In the following sections, we will delve deeper into the pivotal classes within these modules and examine their functions and significance.
