\subsection{Selection}
\label{sec:keen:operators:selection}
  Building upon the concepts presented in \vref{def:selection_operator}, the 
  \emph{selector operator} is mathematically represented as \(\Sigma : \mathbb
  {P} \times \mathbb{N} \times \cdots \to \mathbb{P}\).
  At its core, the selector operator processes a given population 
  \(\mathbb{P}\), selects \(n\) individuals based on specific criteria, and 
  outputs a subset of the initial population.
  To ensure adaptability, the design challenge centers around establishing a 
  versatile interface to cater to diverse selection strategies.

  A promising approach consists of introducing an interface encompassing a 
  method that requires the population and desired number of individuals as 
  inputs.
  We can incorporate any supplementary parameters as properties of a specific 
  selector object.
  This conceptualization can be defined as:

  \begin{code}{Selector interface}{
    label=lst:keen:operators:selection:interface
  }{kotlin}
    interface Selector<DNA, G : Gene<DNA, G>> {
      operator fun invoke(
          population: Population<DNA, G>,
          count: Int,
          optimizer: PhenotypeOptimizer<DNA, G>
      ): Population<DNA, G>
    }
  \end{code}

  In this model, the \texttt{Selector} interface gets parameterized according 
  to the \texttt{DNA} and \texttt{Gene} types.
  The incorporated \texttt{invoke} method explicitly mentions the population, 
  the individual count, and an instance of the \texttt{PhenotypeOptimizer} 
  class.
  Thanks to Kotlin's capacity for operator overloading, this framework allows 
  direct function invocation through the selector object, depicted as \texttt
  {selector(...)}.\footnote{Syntactic sugar for \texttt{selector.invoke(...)}.}

  We introduce an additional parameter, \texttt{PhenotypeOptimizer}, which 
  signifies the optimization strategy employed to facilitate selection, be it 
  maximization or minimization.\footnote{
    Both these strategies - maximization and minimization - are integral 
    components of the \textit{Utility} module in \textit{Keen}.
    Additionally, the \texttt{PhenotypeOptimizer} interface can be modified to 
    support bespoke optimization techniques.
  }

  \begin{remark}
    To add depth to our architecture, the \texttt{Selector} interface 
    seamlessly integrates with the \texttt{AbstractSelector} abstract class.
    This integration ensures foundational functionalities for all selector 
    types, while also allowing developers to design specialized selectors by 
    extending this class.
  \end{remark}

  \subsubsection{Random Selector}
  \label{sec:keen:operators:selection:random}
    The \texttt{RandomSelector} class is a probability selector, which
    is a type of selection strategy that assigns a probability to each
    individual in the population.

    \begin{definition}[Random Selector]
      The \emph{random selector} is a probability selector that assigns the same
      probability to each individual in the population.
      Formally, the \texttt{RandomSelector} is defined as:

      \begin{equation}
        \Sigma_{\mathrm{random}} : \mathbb{P} \times \mathbb{N} \to \mathbb{P};\;
        (P,\, n) \mapsto \Sigma_{\mathrm{random}}(P,\, n)  
      \end{equation}

      where each individual is selected with an uniform distribution of
      probability:

      \begin{equation}
        \rho_i = \frac{1}{|P|}
      \end{equation}
    \end{definition}

    This selector's purpose is to provide a baseline for comparison with other
    selection strategies.
    This kind of selector was not found in the literature, but it is a
    straightforward implementation that can be used as a benchmark.

    Using the WGP as benchmark, we obtained the results shown in \vref
    {tab:keen:operators:selection:random}.

    
  \subsubsection{Roulette Wheel Selector}
  \label{sec:keen:operators:selection:roulette_wheel}
    \Blindtext
  \subsubsection{Tournament Selector}
  \label{sec:keen:operators:selection:tournament}
    \Blindtext
