\subsection{Genetic Material}
\label{sec:keen:ga:material}
  The genetic material stands at the heart of GAs, representing the problem 
  domain's primary aspect.
  Consequently, it's essential to structure this material efficiently and 
  flexibly.

  Our approach is \enquote{gene-centric}.
  Rather than relying on indirect representations, the genetic material is 
  depicted as a collection of genes.
  Such a representation bolsters the flexibility of the API design.
  For instance, the genetic material can manifest as a single gene, a 
  collection of genes (referred to as a chromosome), or even as multiple 
  collections of genes (genotype).

  Furthermore, the genetic material is immutable.
  This immutability ensures thread safety and adheres to the 
  \enquote{copy-on-write} principle, both of which are indispensable for 
  crafting robust GAs.

  \paragraph{Gene}
    The gene stands as the fundamental unit of genetic material within our 
    framework, representing the minutest unit that can undergo manipulation.

    Fundamentally, each gene must be capable of:
    \begin{enumerate*}
      \item \textit{mutation},
      \item \textit{reproduction}, and
      \item \textit{information storage}.
    \end{enumerate*}
    To promote extensibility, genes are designed to handle minimal 
    operations, passing most tasks to operators 
    (refer to \vref{sec:keen:operators}).
    This approach ensures the framework's adaptability across diverse 
    genetic materials, including binary, integer, real, and custom types.

    Thus, we suggest the following interface for gene implementation:

    \begin{code}[Gene interface][label={lst:keen:ga:gene}]{kotlin}
      interface Gene<DNA, G: Gene<DNA, G>> : GeneticMaterial<DNA, G>,
                                              SelfReferential<G> {
          val dna: DNA
          fun mutate(): G
          fun withDna(dna: DNA): G
      }
    \end{code}

  \paragraph{Chromosome}
    A chromosome is defined as an iterable collection of genes.
    Its primary role is to offer a streamlined way to manipulate a group 
    of genes.
    It's crucial to keep the chromosome's responsibilities minimal to 
    foster adaptability across diverse genetic materials.
    
    To this end, we suggest the following interface for each chromosome:
    
    \begin{code}[Chromosome interface][label={lst:keen:ga:chromosome}]{kotlin}
      interface Chromosome<DNA, G : Gene<DNA, G>> : GeneticMaterial<DNA, G>, 
                                                    Iterable<G> {
          val genes: List<G>
          fun withGenes(genes: List<G>): Chromosome<DNA, G>
    
          interface Factory<DNA, G : Gene<DNA, G>> {
              fun make(): Chromosome<DNA, G>
          }
      }
    \end{code}
    
    Incorporated within is the \texttt{Factory} interface, dedicated to 
    the creation of new chromosomes.
    This is harnessed by the framework whenever there's a need to generate 
    new chromosomes.

  \paragraph{Genotype}
    Similar to the chromosome, the genotype serves as an iterable collection 
    of chromosomes.
    Though they share analogous responsibilities, the genotype operates on a 
    broader spectrum.
    While many frameworks tend to merge the definitions of chromosomes and 
    genotypes, distinguishing between them is paramount to our framework's 
    adaptability.
    This distinction facilitates the simultaneous manipulation of multiple 
    chromosomes, paving the way for more intricate genetic materials.
    
    Utilizing parametric polymorphism, we negate the necessity for a 
    hierarchical type relationship between genotypes and chromosomes.
    Consequently, the genotype can be represented by a concrete class, as 
    demonstrated below:
    
    \begin{code}[Genotype class][label={lst:keen:ga:genotype}]{kotlin}
      class Genotype<DNA, G : Gene<DNA, G>>(val chromosomes: List<Chromosome<DNA, G>>) :
          GeneticMaterial<DNA, G>, Iterable<Chromosome<DNA, G>> {
    
          class Factory<DNA, G : Gene<DNA, G>> {
              fun make(): Genotype<DNA, G> { ... }
          }
      }
    \end{code}
    
    Embedded within is the \texttt{Factory} class, designated for the 
    generation of new genotypes.

  \paragraph{Phenotype}
    The phenotype epitomizes the expression of the genetic material.
    Serving as the evaluated manifestation of the genotype, it embodies the 
    candidate solution.
    Fundamentally, the phenotype hinges on:
    \begin{enumerate}
        \item A \textit{fitness} value, and
        \item The associated \textit{genotype}.
    \end{enumerate}
    
    In representing individual entities within a population, it's imperative 
    that a phenotype can be compared with its peers. 
    In light of this, the structure for the phenotype is delineated as:
    
    \begin{code}[Phenotype class][label={lst:keen:ga:phenotype}]{kotlin}
      class Phenotype<DNA, G : Gene<DNA, G>>(
          val genotype: Genotype<DNA, G>,
          val fitness: Double = Double.NaN
      ) : GeneticMaterial<DNA, G>, Comparable<Phenotype<DNA, G>> { ... }
    \end{code}