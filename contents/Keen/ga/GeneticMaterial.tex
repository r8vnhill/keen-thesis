\subsection{Genetic Material}
\label{sec:keen:ga:material}
  The genetic material stands at the heart of GAs, representing the problem domain's primary aspect.
  Consequently, it's essential to structure this material efficiently and flexibly.

  Our approach is \enquote{gene-centric}.
  Rather than relying on indirect representations, the genetic material is 
  depicted as a collection of genes.
  This approach makes our API design more flexible. For example, the genetic material can be a single gene, a group of genes (known as a chromosome), or multiple groups of genes (a genotype).

  Furthermore, the genetic material is immutable.
  This immutability ensures thread safety and adheres to the 
  \enquote{copy-on-write} principle, both of which are indispensable in providing a robust framework.

  \paragraph{Gene}
    The gene stands as the fundamental unit of genetic material within our 
    framework, representing the minutest unit that can undergo manipulation.

    Fundamentally, each gene must be capable of:
    \begin{enumerate*}
      \item \textit{mutation},
      \item \textit{reproduction}, and
      \item \textit{information storage}.
    \end{enumerate*}
    To promote extensibility, genes are designed to handle minimal 
    operations, passing most tasks to operators 
    (refer to \vref{sec:keen:operators}).
    This approach ensures the framework's adaptability across diverse 
    genetic materials, including binary, integer, real, and custom types.

    Thus, we suggest the following interface for gene implementation:

    \begin{code}{Gene interface}{label={lst:keen:ga:gene}}{kotlin}
      interface Gene<T, G> where G : Gene<T, G> {
          val value: T
          fun mutate(): G
          fun duplicateWithValue(value: T): G
      }
    \end{code}

  \paragraph{Chromosome}
    A chromosome is defined as an iterable collection of genes.
    Its primary role is to offer a streamlined way to manipulate a group 
    of genes.
    It's crucial to keep the chromosome's responsibilities minimal to 
    foster adaptability across diverse genetic materials.
    
    To this end, we suggest the following interface for each chromosome:
    
    \begin{code}{Chromosome interface}{label={lst:keen:ga:chromosome}}{kotlin}
      interface Chromosome<T, G> : Collection<G> where G : Gene<T, G> {
          val genes: List<G>
          fun duplicateWithGenes(genes: List<G>): Chromosome<T, G>
          interface Factory<T, G> where G : Gene<T, G> {
              fun make(): Chromosome<T, G>
          }
      }
    \end{code}
    
    Incorporated within is the \texttt{Factory} interface, dedicated to 
    the creation of new chromosomes.
    This is harnessed by the framework whenever there's a need to generate 
    new chromosomes.

  \paragraph{Genotype}
    Like a chromosome, the genotype in our system is an iterable collection of chromosomes. While chromosomes and genotypes have similar functions, the genotype has a wider scope. In our framework, it's important to differentiate between the two, as this allows for handling multiple chromosomes at once. This separation enhances our framework's flexibility and supports the use of more complex genetic materials.
    
    Utilizing parametric polymorphism, we negate the necessity for a 
    hierarchical type relationship between genotypes and chromosomes.
    Consequently, the genotype can be represented by a concrete class, as 
    demonstrated below:
    
    \begin{code}{Genotype class}{label={lst:keen:ga:genotype}}{kotlin}
      data class Genotype<T, G>(val chromosomes: List<Chromosome<T, G>>) :
          Collection<Chromosome<T, G>> where G : Gene<T, G> {
    
          class Factory<DNA, G : Gene<DNA, G>> {
              fun make(): Genotype<DNA, G> { ... }
          }
      }
    \end{code}
    
    Embedded within is the \texttt{Factory} class, designated for the 
    generation of new genotypes.

    Note this implementation does not depend on the \texttt{Chromosome} type,
    thus allowing for the use of any chromosome implementation that adheres to
    the \textit{Gene} type. For example, one could have:

    \begin{code}{Genotype class with custom chromosome}{label={lst:keen:ga:genotype-custom}}{kotlin}
      genotypeOf {
          chromosomeOf {
              intImpl1 { ... }
          }
          chromosomeOf {
              intImpl2 { ... }
          }
      }
    \end{code}

    \noindent where \texttt{intImpl1} and \texttt{intImpl2} are custom 
    implementations of the \texttt{Chromosome} interface.
    Thus allowing more flexibility in the design of the genetic material.

  \paragraph{Individual}
    An individual in our framework represents the actual expression of the genetic material. It acts as the practical form of the genotype and symbolizes a potential solution. Essentially, an individual is defined by two key elements:
    \begin{enumerate}
        \item A \textit{fitness} value,
        \item The corresponding \textit{genotype}.
    \end{enumerate}
    
    In light of this, the structure for the individual is delineated as:
    
    \begin{code}{Individual class}{label={lst:keen:ga:individual}}{kotlin}
      data class Individual<T, G>(
          val genotype: Genotype<T, G>,
          val fitness: Double = Double.NaN
      ) where G : Gene<T, G> { ... }
    \end{code}

